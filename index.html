<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Explore Swiss building data. Open, accessible, and designed for everyone.">
  <title>OpenBuildings.ch</title>

  <!-- Preconnect to external domains (do this FIRST for faster connections) -->
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://api.protomaps.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://vectortiles.geo.admin.ch">

  <!-- Preload critical CSS (starts download immediately) -->
  <link rel="preload" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" as="style">

  <!-- MapLibre GL CSS -->
  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet">

  <!-- Fonts - display=swap already ensures text is visible immediately -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Scripts with defer - downloads in parallel, executes after HTML parsing -->
  <script defer src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    :root {
      /* Primary Colors */
      --clr-deep-blue: #1e3a5f;
      --clr-ocean: #2563eb;
      --clr-sky: #3b82f6;

      /* Accent Colors */
      --clr-leaf: #059669;
      --clr-amber: #d97706;
      --clr-coral: #dc2626;

      /* Neutral Colors (Slate scale) */
      --clr-slate-900: #0f172a;
      --clr-slate-700: #334155;
      --clr-slate-500: #64748b;
      --clr-slate-300: #cbd5e1;
      --clr-slate-200: #e2e8f0;
      --clr-slate-100: #f1f5f9;
      --clr-white: #ffffff;

      /* Semantic mappings */
      --clr-bg: var(--clr-slate-100);
      --clr-surface: var(--clr-white);
      --clr-text: var(--clr-slate-900);
      --clr-text-secondary: var(--clr-slate-700);
      --clr-text-muted: var(--clr-slate-500);
      --clr-border: var(--clr-slate-300);
      --clr-accent: var(--clr-ocean);
      --clr-accent-hover: var(--clr-sky);
      --clr-success: var(--clr-leaf);

      /* Spacing scale (base 4px) */
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      --space-xl: 32px;
      --space-2xl: 48px;

      /* Typography */
      --font-main: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

      /* Borders */
      --radius-sm: 4px;
      --radius-md: 6px;
      --radius-lg: 8px;
    }
    
    body {
      font-family: var(--font-main);
      background: var(--clr-bg);
      color: var(--clr-text);
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    /* Search - Floating overlay style */
    .search-container {
      position: absolute;
      top: var(--space-lg);
      left: var(--space-md);
      z-index: 25;
      width: calc(360px - var(--space-md) * 2);
      max-width: calc(100% - var(--space-md) * 2);
    }

    @media (max-width: 640px) {
      .search-container {
        left: var(--space-sm);
        right: var(--space-sm);
        max-width: calc(100% - var(--space-md));
      }
    }

    .search-input-wrapper {
      display: flex;
      align-items: center;
      background: var(--clr-surface);
      border: 1px solid var(--clr-border);
      border-radius: var(--radius-md);
      padding: 0 var(--space-md);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }

    .search-input-wrapper:focus-within {
      border-color: var(--clr-ocean);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1), 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .search-icon {
      color: var(--clr-text-muted);
      flex-shrink: 0;
    }

    #searchInput {
      flex: 1;
      border: none;
      background: transparent;
      padding: 0.75rem 0.5rem;
      font-size: 1rem;
      font-family: inherit;
      outline: none;
      color: var(--clr-text);
    }

    #searchInput::placeholder {
      color: var(--clr-text-muted);
    }

    .search-clear {
      display: none;
      background: none;
      border: none;
      font-size: 1.25rem;
      color: var(--clr-text-muted);
      cursor: pointer;
      padding: 0 var(--space-xs);
      line-height: 1;
      transition: color 0.15s ease;
    }

    .search-clear:hover {
      color: var(--clr-text);
    }

    .search-input-wrapper.has-value .search-clear {
      display: block;
    }

    .search-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: var(--space-xs);
      background: var(--clr-surface);
      border: 1px solid var(--clr-slate-200);
      border-radius: var(--radius-lg);
      box-shadow: 0 4px 16px rgba(0,0,0,0.12);
      max-height: 400px;
      overflow-y: auto;
      display: none;
      z-index: 100;
    }

    .search-dropdown.open {
      display: block;
    }

    .search-section {
      display: none;
    }

    .search-section.has-results {
      display: block;
    }

    .search-section-header {
      padding: var(--space-sm) var(--space-md);
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--clr-text-muted);
      background: var(--clr-slate-100);
      border-bottom: 1px solid var(--clr-slate-200);
    }

    .search-results {
      max-height: 200px;
      overflow-y: auto;
    }

    .search-result-item {
      padding: var(--space-sm) var(--space-md);
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--clr-text-secondary);
      border-bottom: 1px solid var(--clr-slate-100);
      transition: background 0.1s ease;
    }

    .search-result-item:last-child {
      border-bottom: none;
    }

    .search-result-item:hover {
      background: var(--clr-slate-100);
      color: var(--clr-text);
    }

    .search-result-item.disabled {
      cursor: default;
      opacity: 0.6;
    }

    .search-result-item.disabled:hover {
      background: transparent;
    }

    .search-result-item mark {
      background: rgba(37, 99, 235, 0.15);
      color: var(--clr-ocean);
      padding: 0 2px;
      border-radius: 2px;
    }

    .search-no-results {
      padding: var(--space-md);
      color: var(--clr-text-muted);
      font-size: 0.875rem;
      text-align: center;
    }

    main {
      flex: 1;
      display: flex;
      position: relative;
    }
    
    #map {
      flex: 1;
    }
    
    /* Building Panel - Slide-in from left (Google Maps style) */
    .building-panel {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 360px;
      max-width: 100%;
      background: var(--clr-surface);
      box-shadow: 4px 0 24px rgba(0,0,0,0.12);
      z-index: 20;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding-top: 72px;
    }

    .building-panel.open {
      transform: translateX(0);
    }

    .building-panel-header {
      padding: var(--space-lg);
      border-bottom: 1px solid var(--clr-slate-200);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: var(--space-md);
    }

    .building-panel-title {
      flex: 1;
    }

    .building-panel-title h2 {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--clr-text);
      margin: 0 0 var(--space-xs) 0;
      line-height: 1.3;
    }

    .building-panel-title .location {
      font-size: 0.875rem;
      color: var(--clr-text-muted);
    }

    .building-panel-close {
      background: none;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--clr-text-muted);
      transition: background 0.15s ease, color 0.15s ease;
      flex-shrink: 0;
    }

    .building-panel-close:hover {
      background: var(--clr-slate-100);
      color: var(--clr-text);
    }

    .building-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-lg);
    }

    .building-panel-metrics {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: var(--space-sm) 0;
      border-bottom: 1px solid var(--clr-slate-100);
    }

    .metric-row:last-child {
      border-bottom: none;
    }

    .metric-label {
      font-size: 0.875rem;
      color: var(--clr-text-muted);
    }

    .metric-value {
      font-size: 0.9375rem;
      font-weight: 500;
      color: var(--clr-text);
      text-align: right;
    }

    .building-panel-footer {
      padding: var(--space-lg);
      border-top: 1px solid var(--clr-slate-200);
    }

    .btn-primary {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      width: 100%;
      padding: 12px var(--space-lg);
      background: var(--clr-ocean);
      color: var(--clr-white);
      border: none;
      border-radius: var(--radius-md);
      font-size: 0.9375rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .btn-primary:hover {
      background: var(--clr-sky);
    }

    .btn-primary:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3);
    }

    .btn-primary svg {
      width: 18px;
      height: 18px;
    }

    /* Mobile: Panel slides from bottom */
    @media (max-width: 640px) {
      .building-panel {
        top: auto;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        max-height: 60vh;
        border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        transform: translateY(100%);
        box-shadow: 0 -4px 24px rgba(0,0,0,0.12);
      }

      .building-panel.open {
        transform: translateY(0);
      }
    }

    .loading-overlay {
      position: absolute;
      inset: 0;
      background: var(--clr-slate-100);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 1;
      transition: opacity 0.3s ease;
    }
    
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-spinner {
      width: 36px;
      height: 36px;
      border: 3px solid var(--clr-slate-200);
      border-top-color: var(--clr-ocean);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Basemap selector */
    .basemap-selector {
      position: absolute;
      bottom: var(--space-xl);
      right: var(--space-lg);
      display: flex;
      flex-direction: row-reverse;
      gap: var(--space-sm);
      z-index: 10;
    }

    .basemap-toggle {
      width: 96px;
      height: 96px;
      border-radius: var(--radius-lg);
      border: 3px solid var(--clr-white);
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      cursor: pointer;
      overflow: hidden;
      position: relative;
      background-size: cover;
      background-position: center;
      flex-shrink: 0;
      transition: box-shadow 0.15s ease;
    }

    .basemap-toggle:hover {
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
    }

    .basemap-toggle::after {
      content: 'Basemap';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 0.75rem;
      padding: 4px 6px;
      text-align: center;
      font-weight: 500;
    }

    .basemap-options {
      display: flex;
      gap: var(--space-sm);
      overflow: hidden;
      max-width: 0;
      opacity: 0;
      transition: max-width 0.3s ease, opacity 0.2s ease;
    }

    .basemap-selector.expanded .basemap-options {
      max-width: 500px;
      opacity: 1;
    }

    .basemap-option {
      width: 96px;
      height: 96px;
      border-radius: var(--radius-lg);
      border: 3px solid var(--clr-white);
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      cursor: pointer;
      overflow: hidden;
      position: relative;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      background-size: cover;
      background-position: center;
      flex-shrink: 0;
    }

    .basemap-option:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
    }

    .basemap-option.active {
      border-color: var(--clr-ocean);
      box-shadow: 0 0 0 3px var(--clr-ocean), 0 2px 12px rgba(0,0,0,0.2);
    }

    .basemap-option::after {
      content: attr(data-label);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 0.75rem;
      padding: 4px 6px;
      text-align: center;
      font-weight: 500;
    }
    
    .basemap-option.light, .basemap-toggle.light {
      background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
    }
    
    .basemap-option.streets, .basemap-toggle.streets {
      background: linear-gradient(135deg, #e8f4e5 0%, #ffefd5 50%, #f5f5f5 100%);
    }
    
    .basemap-option.outdoors, .basemap-toggle.outdoors {
      background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 50%, #b8daff 100%);
    }
    
    .basemap-option.satellite, .basemap-toggle.satellite {
      background: linear-gradient(135deg, #2d4a3e 0%, #1a3a2a 50%, #3d5a4e 100%);
    }
    
    /* Custom Map Navigation */
    .map-nav {
      position: absolute;
      top: 50%;
      right: var(--space-lg);
      transform: translateY(-50%);
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
      background: var(--clr-surface);
      border-radius: var(--radius-md);
      padding: var(--space-xs);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .map-nav-btn {
      width: 32px;
      height: 32px;
      background: var(--clr-surface);
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-main);
      font-size: 11px;
      font-weight: 600;
      color: var(--clr-slate-700);
      transition: background 0.15s ease, color 0.15s ease;
    }

    .map-nav-btn:hover {
      background: var(--clr-slate-100);
    }

    .map-nav-btn:focus {
      outline: none;
      box-shadow: 0 0 0 2px var(--clr-ocean);
    }

    .map-nav-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Compass rotation */
    .map-nav-btn#compassBtn svg {
      transition: transform 0.1s ease;
    }

    .map-nav-btn.active {
      background: var(--clr-ocean);
      color: var(--clr-white);
    }

    .map-nav-divider {
      height: 1px;
      background: var(--clr-slate-200);
      margin: var(--space-xs) 0;
    }

    /* Hide default MapLibre navigation */
    .maplibregl-ctrl-top-right {
      display: none;
    }

    /* Cluster count label */
    .cluster-count {
      color: white;
      font-weight: 600;
      font-size: 12px;
      font-family: var(--font-main);
    }

    /* Map Header - Mini header with coords, scale, links */
    .map-header {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      align-items: center;
      gap: var(--space-md);
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(4px);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm) var(--radius-sm) 0 0;
      font-size: 0.75rem;
      color: var(--clr-text-muted);
      box-shadow: 0 -1px 3px rgba(0,0,0,0.1);
    }

    .map-header-coords {
      font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 0.6875rem;
      letter-spacing: -0.02em;
      min-width: 100px;
    }

    .map-header-scale {
      display: flex;
      align-items: center;
      width: 70px;
    }

    /* Override MapLibre scale control styles */
    .map-header-scale .maplibregl-ctrl-scale {
      background: transparent;
      border: none;
      border-bottom: 2px solid var(--clr-slate-500);
      font-size: 0.6875rem;
      color: var(--clr-text-muted);
      padding: 0;
      margin: 0;
      line-height: 1;
    }

    .map-header-links {
      display: flex;
      gap: var(--space-sm);
    }

    .map-header-links a {
      color: var(--clr-text-muted);
      text-decoration: none;
      transition: color 0.15s ease;
    }

    .map-header-links a:hover {
      color: var(--clr-ocean);
    }

    .map-header-divider {
      color: var(--clr-slate-300);
    }

    /* Hide default scale control position */
    .maplibregl-ctrl-bottom-left .maplibregl-ctrl-scale {
      display: none;
    }
  </style>
</head>
<body>
  <main>
    <div id="map"></div>

    <!-- Search overlay -->
    <div class="search-container">
      <div class="search-input-wrapper">
        <svg class="search-icon" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input type="text" id="searchInput" placeholder="Search by address, EGID, or place..." autocomplete="off">
        <button class="search-clear" id="searchClear" type="button" aria-label="Clear search">×</button>
      </div>
      <div class="search-dropdown" id="searchDropdown">
        <div class="search-section" id="locationsSection">
          <div class="search-section-header">Locations</div>
          <div class="search-results" id="locationsResults"></div>
        </div>
        <div class="search-section" id="layersSection">
          <div class="search-section-header">Layers</div>
          <div class="search-results" id="layersResults"></div>
        </div>
      </div>
    </div>

    <!-- Custom Map Navigation -->
    <div class="map-nav">
      <button class="map-nav-btn" id="zoomInBtn" title="Zoom in" aria-label="Zoom in">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      </button>
      <button class="map-nav-btn" id="zoomOutBtn" title="Zoom out" aria-label="Zoom out">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      </button>
      <div class="map-nav-divider"></div>
      <button class="map-nav-btn" id="compassBtn" title="Reset north" aria-label="Reset north">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polygon points="12,2 15,10 12,8 9,10" fill="currentColor" stroke="none"></polygon>
          <polygon points="12,22 9,14 12,16 15,14" fill="none"></polygon>
        </svg>
      </button>
      <button class="map-nav-btn" id="homeBtn" title="Reset view" aria-label="Reset view">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
      </button>
      <button class="map-nav-btn" id="toggle3DBtn" title="Toggle 3D view" aria-label="Toggle 3D view">
        3D
      </button>
    </div>
    <div class="basemap-selector" id="basemapSelector">
      <div class="basemap-toggle light" id="basemapToggle"></div>
      <div class="basemap-options">
        <div class="basemap-option light active" data-style="white" data-label="White"></div>
        <div class="basemap-option streets" data-style="light" data-label="Light"></div>
        <div class="basemap-option outdoors" data-style="grayscale" data-label="Gray"></div>
        <div class="basemap-option satellite" data-style="dark" data-label="Dark"></div>
      </div>
    </div>
    <!-- Building Panel -->
    <aside class="building-panel" id="buildingPanel">
      <div class="building-panel-header">
        <div class="building-panel-title">
          <h2 id="panelBuildingName">Building Name</h2>
          <div class="location" id="panelBuildingLocation">Location</div>
        </div>
        <button class="building-panel-close" id="closePanelBtn" aria-label="Close panel">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      <div class="building-panel-content">
        <div class="building-panel-metrics" id="panelMetrics">
          <!-- Metrics will be populated dynamically -->
        </div>
      </div>
      <div class="building-panel-footer">
        <button class="btn-primary" id="downloadReportBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"></path>
          </svg>
          Download Report
        </button>
      </div>
    </aside>

    <!-- Map Header - scale, coords, links -->
    <div class="map-header" id="mapHeader">
      <div class="map-header-scale" id="scaleContainer"></div>
      <div class="map-header-coords" id="mouseCoords">–</div>
      <div class="map-header-links">
        <a href="https://github.com/davras5/OpenBuildings" target="_blank" rel="noopener">GitHub</a>
        <span class="map-header-divider">·</span>
        <a href="https://awnypgafushbsvqlsjyg.supabase.co" target="_blank" rel="noopener">API</a>
      </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-spinner"></div>
      <span style="margin-top: 12px; color: #64748b; font-size: 14px;">Loading map...</span>
    </div>
  </main>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const SUPABASE_URL = 'https://awnypgafushbsvqlsjyg.supabase.co';
    const SUPABASE_ANON_KEY = 'sb_publishable_PdbeSmuL6XQEaXyaKqhOYQ_fpzIByJQ';
    const PROTOMAPS_KEY = '4d819871947c1005';
    const TILE_SERVER = `${SUPABASE_URL}/functions/v1/tiles`;

    // Swisstopo basemap styles (free for Switzerland, no API key needed)
    const SWISSTOPO_STYLES = {
      light: 'https://vectortiles.geo.admin.ch/styles/ch.swisstopo.lightbasemap.vt/style.json',
      standard: 'https://vectortiles.geo.admin.ch/styles/ch.swisstopo.basemap.vt/style.json',
      satellite: 'https://vectortiles.geo.admin.ch/styles/ch.swisstopo.imagerybasemap.vt/style.json',
      winter: 'https://vectortiles.geo.admin.ch/styles/ch.swisstopo.basemap-winter.vt/style.json'
    };

    // Switzerland bounds for initial view
    const SWITZERLAND_BOUNDS = [5.9559, 45.818, 10.4921, 47.8084];
    
    // ============================================
    // Wait for DOM and scripts to load
    // ============================================
    document.addEventListener('DOMContentLoaded', init);
    
    async function init() {
      // ============================================
      // Initialize Supabase
      // ============================================
      const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      
      // ============================================
      // Initialize Map (MapLibre GL JS with Swisstopo basemaps)
      // ============================================
      const map = new maplibregl.Map({
        container: 'map',
        style: `https://api.protomaps.com/styles/v2/white.json?key=${PROTOMAPS_KEY}`,
        center: [8.2275, 46.8182], // Switzerland center
        zoom: 7,
        maxBounds: [[5.5, 45.5], [11.0, 48.0]] // Restrict to Switzerland region
      });
      
      // Custom zoom controls
      document.getElementById('zoomInBtn').addEventListener('click', () => {
        map.zoomIn({ duration: 300 });
      });
      document.getElementById('zoomOutBtn').addEventListener('click', () => {
        map.zoomOut({ duration: 300 });
      });

      // Add scale control to custom footer container
      const scaleControl = new maplibregl.ScaleControl({ unit: 'metric' });
      const scaleContainer = document.getElementById('scaleContainer');

      // Mount scale control after map loads
      map.on('load', () => {
        scaleControl.onAdd(map);
        scaleContainer.appendChild(scaleControl._container);
      });

      // Mouse coordinates display
      const mouseCoordsDisplay = document.getElementById('mouseCoords');

      map.on('mousemove', (e) => {
        const lng = e.lngLat.lng.toFixed(5);
        const lat = e.lngLat.lat.toFixed(5);
        mouseCoordsDisplay.textContent = `${lng}, ${lat}`;
      });

      map.on('mouseout', () => {
        mouseCoordsDisplay.textContent = '–';
      });

      // ============================================
      // State (selection only - data now served via vector tiles)
      // ============================================

      // ============================================
      // DOM Elements
      // ============================================
      const loadingOverlay = document.getElementById('loadingOverlay');
      const buildingPanel = document.getElementById('buildingPanel');
      const panelBuildingName = document.getElementById('panelBuildingName');
      const panelBuildingLocation = document.getElementById('panelBuildingLocation');
      const panelMetrics = document.getElementById('panelMetrics');
      const closePanelBtn = document.getElementById('closePanelBtn');
      
      // ============================================
      // URL Parameters
      // ============================================
      function getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        return {
          zoom: params.get('zoom') ? parseFloat(params.get('zoom')) : null,
          lon: params.get('lon') ? parseFloat(params.get('lon')) : null,
          lat: params.get('lat') ? parseFloat(params.get('lat')) : null,
          building: params.get('building') ? parseInt(params.get('building')) : null,
          parcel: params.get('parcel') ? parseInt(params.get('parcel')) : null,
          landcover: params.get('landcover') ? parseInt(params.get('landcover')) : null,
          is3D: params.get('3d') === 'true',
          marker: params.get('marker') === 'true'
        };
      }
      
      function updateUrlParams() {
        const params = new URLSearchParams();
        const center = map.getCenter();
        const zoom = map.getZoom();

        params.set('zoom', zoom.toFixed(2));
        params.set('lon', center.lng.toFixed(5));
        params.set('lat', center.lat.toFixed(5));

        if (selectedBuilding) params.set('building', selectedBuilding);
        if (selectedParcel) params.set('parcel', selectedParcel);
        if (selectedLandcover) params.set('landcover', selectedLandcover);
        if (is3DMode) params.set('3d', 'true');

        window.history.replaceState({}, '', `?${params.toString()}`);
      }
      
      // Selection state
      let selectedBuilding = null;
      let selectedParcel = null;
      let selectedLandcover = null;
      let markerClickHandled = false;
      let is3DMode = false;
      let searchMarker = null;
      
      // ============================================
      // Functions
      // ============================================
      
      // Simple EWKB parser for Point and Polygon
      function wkbToGeoJSON(hex) {
        try {
          let pos = 0;
          
          // Helper to read bytes as little-endian double
          function readDouble() {
            const bytes = [];
            for (let i = 0; i < 8; i++) {
              bytes.push(parseInt(hex.substr(pos + i * 2, 2), 16));
            }
            pos += 16;
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            bytes.forEach((b, i) => view.setUint8(i, b));
            return view.getFloat64(0, true);
          }
          
          // Helper to read uint32 little-endian
          function readUInt32() {
            const bytes = [];
            for (let i = 0; i < 4; i++) {
              bytes.push(parseInt(hex.substr(pos + i * 2, 2), 16));
            }
            pos += 8;
            return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
          }
          
          // Skip byte order (1 byte)
          pos += 2;
          
          // Read type (4 bytes) - includes SRID flag
          const type = readUInt32();
          const geomType = type & 0xFF;
          const hasSRID = (type & 0x20000000) !== 0;
          
          // Skip SRID if present (4 bytes)
          if (hasSRID) {
            pos += 8;
          }
          
          // Point (type 1)
          if (geomType === 1) {
            const x = readDouble();
            const y = readDouble();
            return { type: 'Point', coordinates: [x, y] };
          }
          
          // Polygon (type 3)
          if (geomType === 3) {
            const numRings = readUInt32();
            const rings = [];
            
            for (let r = 0; r < numRings; r++) {
              const numPoints = readUInt32();
              const ring = [];
              
              for (let p = 0; p < numPoints; p++) {
                const x = readDouble();
                const y = readDouble();
                ring.push([x, y]);
              }
              rings.push(ring);
            }
            
            return { type: 'Polygon', coordinates: rings };
          }
          
          console.warn('Unsupported geometry type:', geomType);
          return null;
          
        } catch (err) {
          console.error('WKB decode error:', err);
          return null;
        }
      }
      
      // NOTE: fetchBuildings() and fetchParcels() removed - data now served via vector tiles

      function addParcelsLayer() {
        // Skip if source already exists
        if (map.getSource('parcels')) return;

        // Add vector tile source for parcels
        map.addSource('parcels', {
          type: 'vector',
          tiles: [`${TILE_SERVER}/parcels/{z}/{x}/{y}.pbf`],
          minzoom: 10,
          maxzoom: 14,
          bounds: SWITZERLAND_BOUNDS
        });

        // Add fill layer
        map.addLayer({
          id: 'parcels-fill',
          type: 'fill',
          source: 'parcels',
          'source-layer': 'parcels',
          minzoom: 12,
          paint: {
            'fill-color': [
              'case',
              ['==', ['get', 'id'], selectedParcel || -1], '#059669', // Green when selected
              '#1e3a5f' // Deep Blue default
            ],
            'fill-opacity': [
              'case',
              ['==', ['get', 'id'], selectedParcel || -1], 0.3,
              0.1
            ]
          }
        });

        // Add outline layer
        map.addLayer({
          id: 'parcels-outline',
          type: 'line',
          source: 'parcels',
          'source-layer': 'parcels',
          minzoom: 12,
          paint: {
            'line-color': [
              'case',
              ['==', ['get', 'id'], selectedParcel || -1], '#059669',
              '#1e3a5f'
            ],
            'line-width': [
              'case',
              ['==', ['get', 'id'], selectedParcel || -1], 3,
              1.5
            ]
          }
        });

        // Add hover effect
        map.on('mouseenter', 'parcels-fill', () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', 'parcels-fill', () => {
          map.getCanvas().style.cursor = '';
        });

      }

      function addLandcoverLayer() {
        // Skip if source already exists
        if (map.getSource('landcover')) return;

        // Add vector tile source for landcover
        map.addSource('landcover', {
          type: 'vector',
          tiles: [`${TILE_SERVER}/landcover/{z}/{x}/{y}.pbf`],
          minzoom: 10,
          maxzoom: 14,
          bounds: SWITZERLAND_BOUNDS
        });

        // Add flat fill layer (extrusion only in 3D mode)
        // Note: landcover tiles use feature ID, not properties.id, so we use ['id'] expression
        map.addLayer({
          id: 'landcover-fill',
          type: 'fill',
          source: 'landcover',
          'source-layer': 'landcover',
          minzoom: 12,
          paint: {
            'fill-color': [
              'case',
              ['==', ['id'], selectedLandcover || -1], '#059669', // Green when selected
              '#8b5cf6' // Purple default for landcover
            ],
            'fill-opacity': [
              'case',
              ['==', ['id'], selectedLandcover || -1], 0.4,
              0.2
            ]
          }
        });

        // Add outline layer
        // Note: landcover tiles use feature ID, not properties.id, so we use ['id'] expression
        map.addLayer({
          id: 'landcover-outline',
          type: 'line',
          source: 'landcover',
          'source-layer': 'landcover',
          minzoom: 12,
          paint: {
            'line-color': [
              'case',
              ['==', ['id'], selectedLandcover || -1], '#059669',
              '#7c3aed' // Darker purple for outline
            ],
            'line-width': [
              'case',
              ['==', ['id'], selectedLandcover || -1], 3,
              1.5
            ]
          }
        });

        // Add hover effect
        map.on('mouseenter', 'landcover-fill', () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', 'landcover-fill', () => {
          map.getCanvas().style.cursor = '';
        });

      }

      async function addSwitzerlandBorder() {
        if (map.getSource('switzerland-border')) return;

        try {
          const response = await fetch('assets/ch.geojson');
          const geojson = await response.json();

          map.addSource('switzerland-border', {
            type: 'geojson',
            data: geojson
          });

          // Add border line (solid, dark grey - Mapbox style)
          map.addLayer({
            id: 'switzerland-border-line',
            type: 'line',
            source: 'switzerland-border',
            paint: {
              'line-color': '#374151',
              'line-width': 1.5
            }
          });
        } catch (err) {
          console.error('Failed to load Switzerland border:', err);
        }
      }

      function addBuildingsLayer() {
        // Skip if source already exists
        if (map.getSource('buildings')) return;

        // Add vector tile source (streams data on-demand)
        map.addSource('buildings', {
          type: 'vector',
          tiles: [`${TILE_SERVER}/buildings/{z}/{x}/{y}.pbf`],
          minzoom: 0,
          maxzoom: 14,
          bounds: SWITZERLAND_BOUNDS
        });

        // Heatmap layer for low zoom (visual clustering alternative)
        map.addLayer({
          id: 'buildings-heat',
          type: 'heatmap',
          source: 'buildings',
          'source-layer': 'buildings',
          maxzoom: 12,
          paint: {
            'heatmap-weight': 1,
            'heatmap-intensity': ['interpolate', ['linear'], ['zoom'], 0, 0.5, 12, 2],
            'heatmap-radius': ['interpolate', ['linear'], ['zoom'], 0, 3, 12, 15],
            'heatmap-opacity': ['interpolate', ['linear'], ['zoom'], 10, 0.8, 12, 0],
            'heatmap-color': [
              'interpolate', ['linear'], ['heatmap-density'],
              0, 'rgba(0,0,0,0)',
              0.2, '#c7d2fe',  // Light indigo
              0.4, '#818cf8',  // Indigo
              0.6, '#4f46e5',  // Darker indigo
              0.8, '#3730a3',  // Deep indigo
              1, '#1e3a5f'     // Deep Blue (brand color)
            ]
          }
        });

        // Circle layer for individual buildings (visible at zoom 10+)
        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'buildings',
          'source-layer': 'buildings',
          minzoom: 10,
          paint: {
            'circle-radius': [
              'interpolate', ['linear'], ['zoom'],
              10, 2,
              14, ['case', ['==', ['get', 'id'], selectedBuilding || -1], 10, 7]
            ],
            'circle-color': [
              'case',
              ['==', ['get', 'id'], selectedBuilding || -1], '#059669', // Leaf green when selected
              '#64748b' // Slate-500 default
            ],
            'circle-stroke-width': [
              'interpolate', ['linear'], ['zoom'],
              10, 0,
              12, ['case', ['==', ['get', 'id'], selectedBuilding || -1], 3, 2]
            ],
            'circle-stroke-color': [
              'case',
              ['==', ['get', 'id'], selectedBuilding || -1], '#1e3a5f', // Deep Blue
              'white'
            ],
            'circle-opacity': ['interpolate', ['linear'], ['zoom'], 10, 0.3, 12, 1]
          }
        });

        // Click handler for buildings
        map.on('click', 'unclustered-point', (e) => {
          markerClickHandled = true;
          const props = e.features[0].properties;
          const coords = e.features[0].geometry.coordinates;
          selectBuilding(props.id, coords);
          setTimeout(() => { markerClickHandled = false; }, 100);
        });

        // Hover effects
        map.on('mouseenter', 'unclustered-point', () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', 'unclustered-point', () => {
          map.getCanvas().style.cursor = '';
        });
      }

      function updateBuildingStyles() {
        if (!map.getLayer('unclustered-point')) return;

        map.setPaintProperty('unclustered-point', 'circle-radius', [
          'case',
          ['==', ['get', 'id'], selectedBuilding || -1], 10,
          7
        ]);
        map.setPaintProperty('unclustered-point', 'circle-color', [
          'case',
          ['==', ['get', 'id'], selectedBuilding || -1], '#059669', // Leaf green when selected
          '#64748b' // Slate-500 default
        ]);
        map.setPaintProperty('unclustered-point', 'circle-stroke-width', [
          'case',
          ['==', ['get', 'id'], selectedBuilding || -1], 3,
          2
        ]);
        map.setPaintProperty('unclustered-point', 'circle-stroke-color', [
          'case',
          ['==', ['get', 'id'], selectedBuilding || -1], '#1e3a5f', // Deep Blue
          'white'
        ]);
      }
      
      async function selectBuilding(id, coords = null) {
        selectedBuilding = id;
        selectedParcel = null;
        selectedLandcover = null;
        updateUrlParams();
        // For buildings, pass coords directly since showSelectedPanel doesn't have them
        updateBuildingStyles();
        updateParcelStyles();
        updateLandcoverStyles();
        await fetchAndShowBuilding(id, coords);
      }

      async function selectParcel(id) {
        selectedParcel = id;
        selectedBuilding = null;
        selectedLandcover = null;
        updateUrlParams();
        await showSelectedPanel();
      }

      async function selectLandcover(id) {
        selectedLandcover = id;
        selectedBuilding = null;
        selectedParcel = null;
        updateUrlParams();
        await showSelectedPanel();
      }

      // Single function to show panel based on what's selected (from URL params)
      async function showSelectedPanel() {
        updateBuildingStyles();
        updateParcelStyles();
        updateLandcoverStyles();

        if (selectedBuilding) {
          await fetchAndShowBuilding(selectedBuilding);
        } else if (selectedLandcover) {
          await fetchAndShowLandcover(selectedLandcover);
        } else if (selectedParcel) {
          await fetchAndShowParcel(selectedParcel);
        }
      }

      // Fetch building from Supabase and show panel
      async function fetchAndShowBuilding(id, coords = null) {
        try {
          const { data, error } = await db
            .from('buildings')
            .select('id, name, egid, geog')
            .eq('id', id)
            .single();

          if (error) throw error;

          if (data) {
            // Parse coordinates from geog if available
            let lon, lat;
            if (coords) {
              [lon, lat] = coords;
            } else if (data.geog) {
              const geojson = wkbToGeoJSON(data.geog);
              if (geojson) {
                lon = geojson.coordinates[0];
                lat = geojson.coordinates[1];
              }
            }

            showBuildingPanel({
              id: data.id,
              name: data.name,
              egid: data.egid,
              lon,
              lat
            });
          }
        } catch (err) {
          console.error('Error fetching building:', err);
        }
      }

      // Fetch parcel from Supabase and show panel
      async function fetchAndShowParcel(id) {
        try {
          const { data, error } = await db
            .from('parcels')
            .select('id, name, egrid, building_id')
            .eq('id', id)
            .single();

          if (error) throw error;

          if (data) {
            showParcelPanel(data);
          }
        } catch (err) {
          console.error('Error fetching parcel:', err);
        }
      }

      // Fetch landcover from Supabase and show panel
      async function fetchAndShowLandcover(id) {
        try {
          const { data, error } = await db
            .from('landcover')
            .select('id, type, area_m2')
            .eq('id', id)
            .single();

          if (error) throw error;

          if (data) {
            showLandcoverPanel(data);
          }
        } catch (err) {
          console.error('Error fetching landcover:', err);
        }
      }

      function updateParcelStyles() {
        if (!map.getLayer('parcels-fill')) return;

        if (selectedParcel) {
          map.setPaintProperty('parcels-fill', 'fill-opacity', [
            'case',
            ['==', ['get', 'id'], selectedParcel], 0.25,
            0.1
          ]);
          map.setPaintProperty('parcels-outline', 'line-width', [
            'case',
            ['==', ['get', 'id'], selectedParcel], 3,
            1.5
          ]);
        } else {
          map.setPaintProperty('parcels-fill', 'fill-opacity', 0.1);
          map.setPaintProperty('parcels-outline', 'line-width', 1.5);
        }
      }

      function updateLandcoverStyles() {
        if (!map.getLayer('landcover-fill')) return;

        // Use appropriate property based on layer type
        const opacityProp = is3DMode ? 'fill-extrusion-opacity' : 'fill-opacity';

        // Note: landcover tiles use feature ID, not properties.id, so we use ['id'] expression
        if (selectedLandcover) {
          map.setPaintProperty('landcover-fill', opacityProp, [
            'case',
            ['==', ['id'], selectedLandcover], is3DMode ? 0.6 : 0.4,
            is3DMode ? 0.4 : 0.2
          ]);
          map.setPaintProperty('landcover-outline', 'line-width', [
            'case',
            ['==', ['id'], selectedLandcover], 3,
            1.5
          ]);
        } else {
          map.setPaintProperty('landcover-fill', opacityProp, is3DMode ? 0.4 : 0.2);
          map.setPaintProperty('landcover-outline', 'line-width', 1.5);
        }
      }

      // Show building panel with details
      function showBuildingPanel(building) {
        // Title: name → egid → #id
        const title = building.name || building.egid || `#${building.id}`;
        panelBuildingName.textContent = title;
        panelBuildingLocation.textContent = 'Building';

        const hasCoords = building.lat != null && building.lon != null;

        // Build metrics HTML
        const metrics = [
          { label: 'EGID', value: building.egid || '–' }
        ];

        if (hasCoords) {
          metrics.push({ label: 'Coordinates', value: `${building.lat.toFixed(5)}, ${building.lon.toFixed(5)}` });
        }

        panelMetrics.innerHTML = metrics.map(m => `
          <div class="metric-row">
            <span class="metric-label">${m.label}</span>
            <span class="metric-value">${m.value}</span>
          </div>
        `).join('');

        buildingPanel.classList.add('open');
      }

      // Show parcel panel with details
      function showParcelPanel(parcel) {
        // Title: egrid → #id
        const title = parcel.egrid || `#${parcel.id}`;
        panelBuildingName.textContent = title;
        panelBuildingLocation.textContent = 'Parcel';

        // Build metrics HTML
        const metrics = [
          { label: 'E-GRID', value: parcel.egrid || '–' },
          { label: 'ID', value: parcel.id || '–' }
        ];

        // Add building reference if exists
        if (parcel.building_id) {
          metrics.push({ label: 'Building ID', value: parcel.building_id });
        }

        panelMetrics.innerHTML = metrics.map(m => `
          <div class="metric-row">
            <span class="metric-label">${m.label}</span>
            <span class="metric-value">${m.value}</span>
          </div>
        `).join('');

        buildingPanel.classList.add('open');
      }

      // Format landcover type for display (e.g., 'road_path' → 'Road/Path')
      function formatLandcoverType(type) {
        if (!type) return 'Unknown';

        const typeLabels = {
          'building': 'Building',
          'hardened_area': 'Hardened Area',
          'greenhouse': 'Greenhouse',
          'perennial_culture_shelter': 'Perennial Culture Shelter',
          'reservoir': 'Reservoir',
          'other_hardened': 'Other Hardened',
          'railway': 'Railway',
          'road_path': 'Road/Path',
          'field_meadow_pasture': 'Field/Meadow/Pasture',
          'vineyard': 'Vineyard',
          'other_intensive_culture': 'Other Intensive Culture',
          'garden': 'Garden',
          'moor': 'Moor',
          'other_humusised': 'Other Humusised',
          'standing_water': 'Standing Water',
          'flowing_water': 'Flowing Water',
          'reed_belt': 'Reed Belt',
          'closed_forest': 'Closed Forest',
          'dense_wooded_pasture': 'Dense Wooded Pasture',
          'open_wooded_pasture': 'Open Wooded Pasture',
          'other_wooded': 'Other Wooded',
          'rock': 'Rock',
          'glacier_firn': 'Glacier/Firn',
          'gravel_sand': 'Gravel/Sand',
          'quarry_dump': 'Quarry/Dump',
          'other_unvegetated': 'Other Unvegetated'
        };

        return typeLabels[type] || type.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      }

      // Show landcover panel with details
      function showLandcoverPanel(landcover) {
        // Title: formatted type → #id
        const title = formatLandcoverType(landcover.type) || `#${landcover.id}`;
        panelBuildingName.textContent = title;
        panelBuildingLocation.textContent = 'Landcover';

        // Build metrics HTML
        const metrics = [
          { label: 'ID', value: landcover.id || '–' }
        ];

        // Add area if available
        if (landcover.area_m2) {
          metrics.push({ label: 'Area', value: `${landcover.area_m2.toLocaleString()} m²` });
        }

        panelMetrics.innerHTML = metrics.map(m => `
          <div class="metric-row">
            <span class="metric-label">${m.label}</span>
            <span class="metric-value">${m.value}</span>
          </div>
        `).join('');

        buildingPanel.classList.add('open');
      }

      // Close panel
      function closeBuildingPanel() {
        buildingPanel.classList.remove('open');
        selectedBuilding = null;
        selectedParcel = null;
        selectedLandcover = null;
        updateBuildingStyles();
        updateParcelStyles();
        updateLandcoverStyles();
        updateUrlParams();
      }

      // Panel close button
      closePanelBtn.addEventListener('click', closeBuildingPanel);

      async function flyToBuilding(id) {
        try {
          const { data, error } = await db
            .from('buildings')
            .select('id, name, egid, geog')
            .eq('id', id)
            .single();

          if (error) throw error;

          if (data && data.geog) {
            const geojson = wkbToGeoJSON(data.geog);
            if (geojson) {
              const [lon, lat] = geojson.coordinates;

              map.flyTo({
                center: [lon, lat],
                zoom: 14,
                duration: 1500
              });

              showBuildingPanel({
                id: data.id,
                name: data.name,
                egid: data.egid,
                lon,
                lat
              });
            }
          }
        } catch (err) {
          console.error('Error flying to building:', err);
        }
      }

      function goHome() {
        map.fitBounds(SWITZERLAND_BOUNDS, {
          padding: 40,
          duration: 1000
        });
      }
      
      // ============================================
      // Initialize
      // ============================================
      const urlParams = getUrlParams();
      
      // Apply URL params for initial selection
      if (urlParams.building) selectedBuilding = urlParams.building;
      if (urlParams.parcel) selectedParcel = urlParams.parcel;
      if (urlParams.landcover) selectedLandcover = urlParams.landcover;
      if (urlParams.is3D) is3DMode = true;

      // Set initial view from URL if provided
      if (urlParams.zoom && urlParams.lon && urlParams.lat) {
        map.setCenter([urlParams.lon, urlParams.lat]);
        map.setZoom(urlParams.zoom);

        // Create search marker if marker param is true
        if (urlParams.marker) {
          const el = document.createElement('div');
          el.innerHTML = `
            <svg width="32" height="40" viewBox="0 0 32 40" fill="none">
              <path d="M16 0C7.163 0 0 7.163 0 16c0 12 16 24 16 24s16-12 16-24c0-8.837-7.163-16-16-16z" fill="#2563eb"/>
              <circle cx="16" cy="16" r="6" fill="white"/>
            </svg>
          `;
          el.style.cssText = 'cursor: pointer; transform: translate(-50%, -100%);';

          searchMarker = new maplibregl.Marker({ element: el })
            .setLngLat([urlParams.lon, urlParams.lat])
            .addTo(map);
        }
      }
      
      map.on('load', async () => {
        // Add Switzerland border first (below other layers)
        await addSwitzerlandBorder();

        // Add vector tile layers (no data fetching needed!)
        // Layer order: parcels (bottom) -> landcover (middle) -> buildings (top)
        addParcelsLayer();
        addLandcoverLayer();
        addBuildingsLayer();

        // Unified click handler for parcels and landcover (respects layer hierarchy)
        // Buildings have their own handler with markerClickHandled flag
        map.on('click', (e) => {
          // Skip if a building marker was clicked (handled by building layer)
          if (markerClickHandled) return;

          // Query features at click point - check in priority order (top to bottom)
          const landcoverFeatures = map.queryRenderedFeatures(e.point, { layers: ['landcover-fill'] });
          const parcelFeatures = map.queryRenderedFeatures(e.point, { layers: ['parcels-fill'] });

          // Select based on layer hierarchy: landcover (middle) > parcels (bottom)
          // Note: landcover uses feature.id, parcels use properties.id
          if (landcoverFeatures.length > 0) {
            selectLandcover(landcoverFeatures[0].id);
          } else if (parcelFeatures.length > 0) {
            selectParcel(parcelFeatures[0].properties.id);
          }
        });

        // If no URL params, fit to Switzerland
        if (!urlParams.zoom) {
          map.fitBounds(SWITZERLAND_BOUNDS, { padding: 40, duration: 1000 });
        }

        // Show panel for selected item from URL params
        await showSelectedPanel();

        // Apply 3D mode from URL params
        if (is3DMode) {
          setup3DTerrain();
          map.setPitch(60);
          toggle3DButton.textContent = '2D';
        }

        loadingOverlay.classList.add('hidden');
      });
      
      // Update URL on map move
      map.on('moveend', updateUrlParams);
      
      // ============================================
      // Home Button
      // ============================================
      const homeButton = document.getElementById('homeBtn');
      homeButton.addEventListener('click', goHome);

      // Compass button - reset north
      const compassBtn = document.getElementById('compassBtn');
      const compassSvg = compassBtn.querySelector('svg');

      compassBtn.addEventListener('click', () => {
        map.easeTo({ bearing: 0, pitch: 0, duration: 500 });
      });

      // Rotate compass with map bearing
      map.on('rotate', () => {
        const bearing = map.getBearing();
        compassSvg.style.transform = `rotate(${-bearing}deg)`;
      });
      
      // ============================================
      // Basemap Selector
      // ============================================
      const basemapSelector = document.getElementById('basemapSelector');
      const basemapToggle = document.getElementById('basemapToggle');
      const basemapOptions = document.querySelectorAll('.basemap-option');
      
      // Toggle expand/collapse
      basemapToggle.addEventListener('click', () => {
        basemapSelector.classList.toggle('expanded');
      });
      
      // Close when clicking outside
      document.addEventListener('click', (e) => {
        if (!basemapSelector.contains(e.target)) {
          basemapSelector.classList.remove('expanded');
        }
      });
      
      basemapOptions.forEach(option => {
        option.addEventListener('click', () => {
          const styleKey = option.dataset.style;
          const styleClass = option.classList[1]; // light, streets, outdoors, satellite

          // Update active state
          basemapOptions.forEach(o => o.classList.remove('active'));
          option.classList.add('active');

          // Update toggle appearance
          basemapToggle.className = 'basemap-toggle ' + styleClass;

          // Collapse selector
          basemapSelector.classList.remove('expanded');

          // Change map style (Protomaps)
          map.setStyle(`https://api.protomaps.com/styles/v2/${styleKey}.json?key=${PROTOMAPS_KEY}`);

          // Re-add layers after new style loads
          map.once('style.load', async () => {
            // Re-add Switzerland border first
            await addSwitzerlandBorder();

            // Re-add vector tile layers in correct order
            // Layer order: parcels (bottom) -> landcover (middle) -> buildings (top)
            addParcelsLayer();
            addLandcoverLayer();
            addBuildingsLayer();

            // Re-add unified click handler for parcels and landcover
            // Note: landcover uses feature.id, parcels use properties.id
            map.on('click', (e) => {
              if (markerClickHandled) return;
              const landcoverFeatures = map.queryRenderedFeatures(e.point, { layers: ['landcover-fill'] });
              const parcelFeatures = map.queryRenderedFeatures(e.point, { layers: ['parcels-fill'] });
              if (landcoverFeatures.length > 0) {
                selectLandcover(landcoverFeatures[0].id);
              } else if (parcelFeatures.length > 0) {
                selectParcel(parcelFeatures[0].properties.id);
              }
            });

            // Re-apply 3D mode if active
            if (is3DMode) {
              setup3DTerrain();
            }
          });
        });
      });

      // ============================================
      // 3D Toggle
      // ============================================
      const toggle3DButton = document.getElementById('toggle3DBtn');

      function setup3DTerrain() {
        console.log('Setting up 3D terrain...');

        // Add AWS Terrarium terrain source if not exists
        if (!map.getSource('terrain-dem')) {
          console.log('Adding terrain-dem source');
          map.addSource('terrain-dem', {
            type: 'raster-dem',
            tiles: ['https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png'],
            encoding: 'terrarium',
            tileSize: 256,
            maxzoom: 15
          });
        }

        // Enable terrain
        try {
          map.setTerrain({ source: 'terrain-dem', exaggeration: 1.5 });
          console.log('Terrain enabled');

          // Force terrain tiles to reload at correct LOD by triggering a tiny zoom adjustment
          const currentZoom = map.getZoom();
          map.setZoom(currentZoom - 0.01);
          requestAnimationFrame(() => map.setZoom(currentZoom));
        } catch (err) {
          console.error('Failed to enable terrain:', err);
        }

        // Convert landcover (building footprints) to fill-extrusion for 3D view
        if (map.getLayer('landcover-fill')) {
          console.log('Converting landcover to fill-extrusion');
          try {
            // Get the outline layer position if it exists
            const beforeLayer = map.getLayer('landcover-outline') ? 'landcover-outline' : undefined;

            map.removeLayer('landcover-fill');
            // Note: landcover tiles use feature ID, not properties.id, so we use ['id'] expression
            map.addLayer({
              id: 'landcover-fill',
              type: 'fill-extrusion',
              source: 'landcover',
              'source-layer': 'landcover',
              minzoom: 12,
              paint: {
                'fill-extrusion-color': [
                  'case',
                  ['==', ['id'], selectedLandcover || -1], '#059669',
                  '#8b5cf6'
                ],
                'fill-extrusion-height': 10,
                'fill-extrusion-base': 0,
                'fill-extrusion-opacity': 0.8
              }
            }, beforeLayer);
            console.log('Landcover fill-extrusion layer added successfully');
          } catch (err) {
            console.error('Failed to add landcover fill-extrusion:', err);
          }
        } else {
          console.warn('landcover-fill layer not found');
        }
      }

      function remove3DTerrain() {
        console.log('Removing 3D terrain...');

        // Disable terrain
        map.setTerrain(null);

        // Convert landcover back to flat fill
        if (map.getLayer('landcover-fill')) {
          console.log('Converting landcover back to flat fill');
          try {
            const beforeLayer = map.getLayer('landcover-outline') ? 'landcover-outline' : undefined;

            map.removeLayer('landcover-fill');
            // Note: landcover tiles use feature ID, not properties.id, so we use ['id'] expression
            map.addLayer({
              id: 'landcover-fill',
              type: 'fill',
              source: 'landcover',
              'source-layer': 'landcover',
              minzoom: 12,
              paint: {
                'fill-color': [
                  'case',
                  ['==', ['id'], selectedLandcover || -1], '#059669',
                  '#8b5cf6'
                ],
                'fill-opacity': [
                  'case',
                  ['==', ['id'], selectedLandcover || -1], 0.4,
                  0.2
                ]
              }
            }, beforeLayer);
          } catch (err) {
            console.error('Failed to restore landcover fill:', err);
          }
        }
      }

      function toggle3D() {
        is3DMode = !is3DMode;

        if (is3DMode) {
          setup3DTerrain();
          // Pitch camera for 3D perspective
          map.easeTo({ pitch: 60, duration: 1000 });
          toggle3DButton.textContent = '2D';
        } else {
          remove3DTerrain();
          // Reset camera to flat view
          map.easeTo({ pitch: 0, duration: 1000 });
          toggle3DButton.textContent = '3D';
        }

        updateUrlParams();
      }

      toggle3DButton.addEventListener('click', toggle3D);

      // ============================================
      // Swisstopo Search
      // ============================================
      const searchInput = document.getElementById('searchInput');
      const searchClear = document.getElementById('searchClear');
      const searchDropdown = document.getElementById('searchDropdown');
      const locationsSection = document.getElementById('locationsSection');
      const locationsResults = document.getElementById('locationsResults');
      const layersSection = document.getElementById('layersSection');
      const layersResults = document.getElementById('layersResults');
      const searchInputWrapper = searchInput.parentElement;

      let searchDebounceTimer = null;
      
      // Debounced search
      function debounce(fn, delay) {
        return (...args) => {
          clearTimeout(searchDebounceTimer);
          searchDebounceTimer = setTimeout(() => fn(...args), delay);
        };
      }
      
      // Search API call
      async function searchSwisstopo(query) {
        if (!query || query.length < 2) {
          closeSearchDropdown();
          return;
        }
        
        try {
          const url = `https://api3.geo.admin.ch/rest/services/ech/SearchServer?searchText=${encodeURIComponent(query)}&type=locations&type=layers&lang=de&sr=4326`;
          const response = await fetch(url);
          const data = await response.json();
          
          displaySearchResults(data.results, query);
        } catch (err) {
          console.error('Search error:', err);
        }
      }
      
      // Highlight matching text
      function highlightMatch(text, query) {
        if (!text) return '';
        const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        return text.replace(regex, '<mark>$1</mark>');
      }
      
      // Display results
      function displaySearchResults(results, query) {
        const locations = results.filter(r => r.attrs.origin === 'address' || r.attrs.origin === 'zipcode' || r.attrs.origin === 'sn25' || r.attrs.origin === 'gg25' || r.attrs.origin === 'district' || r.attrs.origin === 'canton' || r.attrs.origin === 'gazetteer');
        const layers = results.filter(r => r.attrs.origin === 'layer');
        
        // Clear previous results
        locationsResults.innerHTML = '';
        layersResults.innerHTML = '';
        
        // Locations
        if (locations.length > 0) {
          locationsSection.classList.add('has-results');
          locations.slice(0, 10).forEach(loc => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            item.innerHTML = highlightMatch(loc.attrs.label.replace(/<[^>]*>/g, ''), query);
            item.addEventListener('click', () => {
              goToLocation(loc);
            });
            locationsResults.appendChild(item);
          });
        } else {
          locationsSection.classList.remove('has-results');
        }
        
        // Layers (disabled for now)
        if (layers.length > 0) {
          layersSection.classList.add('has-results');
          layers.slice(0, 10).forEach(layer => {
            const item = document.createElement('div');
            item.className = 'search-result-item disabled';
            item.innerHTML = highlightMatch(layer.attrs.label.replace(/<[^>]*>/g, ''), query);
            layersResults.appendChild(item);
          });
        } else {
          layersSection.classList.remove('has-results');
        }
        
        // Show dropdown if we have results
        if (locations.length > 0 || layers.length > 0) {
          searchDropdown.classList.add('open');
        } else {
          closeSearchDropdown();
        }
      }
      
      // Go to location
      function goToLocation(loc) {
        // With sr=4326, y=lat, x=lon in WGS84
        const lon = loc.attrs.x;
        const lat = loc.attrs.y;
        
        // Remove existing search marker
        if (searchMarker) {
          searchMarker.remove();
        }
        
        // Create new search marker (different style from building markers)
        const el = document.createElement('div');
        el.innerHTML = `
          <svg width="32" height="40" viewBox="0 0 32 40" fill="none">
            <path d="M16 0C7.163 0 0 7.163 0 16c0 12 16 24 16 24s16-12 16-24c0-8.837-7.163-16-16-16z" fill="#2563eb"/>
            <circle cx="16" cy="16" r="6" fill="white"/>
          </svg>
        `;
        el.style.cssText = 'cursor: pointer; transform: translate(-50%, -100%);';
        
        searchMarker = new maplibregl.Marker({ element: el })
          .setLngLat([lon, lat])
          .addTo(map);
        
        // Fly to location
        map.flyTo({
          center: [lon, lat],
          zoom: 17,
          duration: 1500
        });
        
        closeSearchDropdown();
      }
      
      function closeSearchDropdown() {
        searchDropdown.classList.remove('open');
      }
      
      // Input handlers
      const debouncedSearch = debounce(searchSwisstopo, 300);
      
      searchInput.addEventListener('input', (e) => {
        const value = e.target.value.trim();
        
        if (value) {
          searchInputWrapper.classList.add('has-value');
        } else {
          searchInputWrapper.classList.remove('has-value');
        }
        
        debouncedSearch(value);
      });
      
      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim().length >= 2) {
          debouncedSearch(searchInput.value.trim());
        }
      });
      
      searchClear.addEventListener('click', () => {
        searchInput.value = '';
        searchInputWrapper.classList.remove('has-value');
        closeSearchDropdown();
        searchInput.focus();
      });
      
      // Close dropdown on outside click
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-container')) {
          closeSearchDropdown();
        }
      });
      
      // Close on escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeSearchDropdown();
          searchInput.blur();
        }
      });
    }
  </script>
</body>
</html>
